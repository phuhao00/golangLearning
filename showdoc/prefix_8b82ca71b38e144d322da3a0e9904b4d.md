
#Golang调度器GMP原理与调度全分析





###一、Golang“调度器”的由来？

(1) 单进程时代不需要调度器

我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是“单进程时代”

####1.早期的单进程操作系统，面临2个问题：

1.单一的执行流程，计算机只能一个任务一个任务处理。

2.进程阻塞所带来的CPU时间浪费。

那么能不能有多个进程来宏观一起来执行多个任务呢？

后来操作系统就具有了最早的并发能力：多进程并发，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。

####多进程/线程时代有了调度器需求

![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/187e8502d5b83398a68e302d0f4b64d7&showdoc=.jpg)

这就是cpu时间片的概念
#####解决方案：
在多进程/多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。

#####出现的问题：

但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了

####2.怎么才能提高CPU的利用率呢？

但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。

![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/1f88b2b4cf5cd8b83a40a8071221a68b&showdoc=.jpg)



很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。

####3.协程来提高CPU利用率

多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用4GB[32位操作系统], 而线程也要大约4MB)。

大量的进程/线程出现了新的问题

高内存占用

调度的高消耗CPU

好了，然后工程师们就发现，其实一个线程分为“内核态“线程和”用户态“线程。

一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。



##线程模型讲起

###1:1的内核线程模型

![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/0bc23d728e10c1a21a134679bc8c4182&showdoc=.jpg)

优点：

1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点，

缺点：

协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。

###N:1的内核线程模型

![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/13d2e32fb68d40c81c77228304c7bc88&showdoc=.jpg)


优点

N个协程绑定1个线程，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。

缺点：

但也有很大的缺点，1个进程的所有协程都绑定在1个线程上
例如某个程序用不了硬件的多核加速能力
一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。


###N:M的内核线程模型
![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/2e6cdf8a712488f07acda70dc2a9a0af&showdoc=.jpg)

协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。




![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/9c8a5c4df7299cf4b9c4c94355c6c7fa&showdoc=.jpg)

Mechine   :一个mechine对应一个内核线程，相当内核线程在go语言层级的映射

Processsor：是一个抽象的概念，并不是真正的物理CPU。所以当P有任务时需要创建或者唤醒一个系统线程来执行它队列里的任务。所以P/M需要进行绑定，构成一个执行单元。

Goroutine： 相当于操作系统中的进程控制块，在这里就是Goroutine的控制结构，是对Goroutine的抽象。其中包括执行的函数指令及参数；G保存的任务对象；线程上下文切换，现场保护和现场恢复需要的寄存器(SP、IP)等信息。






##GMP调度


![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/7da81f9bb9f7b999c0392d2fa0947b87&showdoc=.jpg)

**全局队列（Global Queue）**：存放等待运行的G。

**P的本地队列**：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。

**P列表**：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS(可配置)个。

**M**：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行。

有关P和M的个数问题

**1、P的数量：**

由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS个goroutine在同时运行，如果我们把p的数量设置大于CPU核心数量，其实没有太大意义，最大数值是256

**2、M的数量:**

go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。

runtime/debug中的SetMaxThreads函数，设置M的最大数量

一个M阻塞了，会创建新的M。

M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。

P和M何时会被创建

1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。

2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。


##调度器策略

复用线程：避免频繁的创建、销毁线程，而是对线程的复用。

1）work stealing机制

​      当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。

2）hand off机制

​      当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。

利用并行：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。

抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。

全局G队列：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G