# Rabbitmq核心概念
### VirtualHost
	RabbitMq 当中的 VirtualHost（虚拟消息服务器），每个 VirtualHost 相当于一个相对独立的 RabbitMQ 服务器，每个 VirtualHost 之间是相互隔离的，拿数据库 mysql 类类比，RabbitMq 相当于 mysql,RabbitMq 中的 VirtualHost 就相当于 mysql 当中的一个库

### Connections
	只要我们的 rabbitmq 监听进程以后，那么这个链接就会在 Connections 当中展示链接，只要我们的 rabbitmq 监听进程以后，那么这个链接就会在 Connections 当中展示

### channel
	我们知道无论是生产者还是消费者，都需要和 RabbitMQ Broker 建立连接，这个连接就是一条 TCP 连接，也就是 Connection。
	一旦 TCP 连接建立起来，客户端紧接着可以创建一个 AMQP 信道（Channel），每个信道都会被指派一个唯一的 ID。
	信道是建立在 Connection 之上的虚拟连接，RabbitMQ 处理的每条 AMQP 指令都是通过信道完成的
	我们完全可以使用 Connection 就能完成信道的工作，为什么还要引入信道呢？
	试想这样一个场景，一个应用程序中有很多个线程需要从 RabbitMQ 中消费消息，或者生产消息，那么必然需要建立很多个 Connection，也就是多个 TCP 连接。
	然而对于操作系统而言，建立和销毁 TCP 连接是非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。
	RabbitMQ 采用类似 NIO（Non-blocking I/O）的做法，选择 TCP 连接复用，不仅可以减少性能开销，同时也便于管理。
	每个线程把持一个信道，所以信道复用了 Connection 的 TCP 连接。同时 RabbitMQ 可以确保每个线程的私密性，就像拥有独立的连接一样。当每个信道的流量不是很大时，复用单一的 Connection 可以在产生性能瓶颈的情况下有效地节省 TCP 连接资源。但是信道本身的流量很大时，这时候多个信道复用一个 Connection 就会产生性能瓶颈，进而使整体的流量被限制了。此时就需要开辟多个 Connection，将这些信道均摊到这些 Connection 中，至于这些相关的调优策略需要根据业务自身的实际情况进行调节

### Queues
	队列
	队列会绑定到交换机上 交换机会根据绑定键将数据发送到不同的队列里面去 没有被消费的数据会被保存在队列里面 不废话了 redis 里面不就有 list 吗 那是模拟的消息队列 就这么个意思！

### Binding
	通过 Binding 将队列绑定到交换机上 有不同的绑定方式 可以实现不同的功能

# Rabbitmq工作模式
### Rabbitmq工作模式之simple模式
	1. 消息产生着将消息放入队列
	2. 消息的消费者 (consumer) 监听 (while) 消息队列，如果队列中有消息，就消费掉，消息被拿走后，自动从队列中删除 (隐患 消息可能没有被消费者正确处理，已经从队列中消失了，造成消息的丢失) 应用场景：聊天 (中间有一个过度的服务器；p 端，c 端)
![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/a66dfc48a5aa31486b33a9b557ff6faa&showdoc=.jpg)
	生产者 ——> 队列 ——> 消费者
	就这么简单，你可以理解为 redis 里面的 list “队列”，另外多说一句 redis 里面的队列都是用 list 来模拟的，不要以为 list 就是队列，它，不是！充其量是一个列表，stream 类型是 redis5 新出的，stream 还可以够的上是一个队列，并且是乞丐版的 kafka, 应对一般的流量冲击还是搓搓有余的！
	
# 工作机制
### 生产者、消费者和代理
	在了解消息通讯之前首先要了解 3 个概念：生产者、消费者和代理。
	生产者：消息的创建者，负责创建和推送数据到消息服务器；
	消费者：消息的接收方，用于处理数据和确认消息；
	代理：就是 RabbitMQ 本身，用于扮演 “快递” 的角色，本身不生产消息，只是扮演 “快递” 的角色。

### 消息发送原理
	首先你必须连接到 Rabbit 才能发布和消费消息，那怎么连接和发送消息的呢？
	你的应用程序和 Rabbit Server 之间会创建一个 TCP 连接，一旦 TCP 打开，并通过了认证，认证就是你试图连接 Rabbit 之前发送的 Rabbit 服务器连接信息和用户名和密码，有点像程序连接数据库，使用 Java 有两种连接认证的方式，后面代码会详细介绍，一旦认证通过你的应用程序和 Rabbit 就创建了一条 AMQP 信道（Channel）
	信道是创建在 “真实” TCP 上的虚拟连接，AMQP 命令都是通过信道发送出去的，每个信道都会有一个唯一的 ID，不论是发布消息，订阅队列或者介绍消息都是通过信道完成的。

### ##### 为什么不通过 TCP 直接发送命令？
	对于操作系统来说创建和销毁 TCP 会话是非常昂贵的开销，假设高峰期每秒有成千上万条连接，每个连接都要创建一条 TCP 会话，这就造成了 TCP 连接的巨大浪费，而且操作系统每秒能创建的 TCP 也是有限的，因此很快就会遇到系统瓶颈。
	如果我们每个请求都使用一条 TCP 连接，既满足了性能的需要，又能确保每个连接的私密性，这就是引入信道概念的原因

### Rabbitmq工作模式work工作模式
	1. 消息产生者将消息放入队列消费者可以有多个，消费者 1, 消费者 2, 同时监听同一个队列，消息被消费？C1 C2 共同争抢当前的消息队列内容，谁先拿到谁负责消费消息 (隐患，高并发情况下，默认会产生某一个消息被多个消费者共同使用，可以设置一个开关 (syncronize, 与同步锁的性能不一样) 保证一条消息只能被一个消费者使用)
	2. 应用场景：红包；大项目中的资源调度 (任务分配系统不需知道哪一个任务执行系统在空闲，直接将任务扔到消息队列中，空闲的系统自动争抢)
![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/4351d613722bc1de23750ce63e341a54&showdoc=.jpg)
	一个消息只能被一个消费者获取
	当生产者生产消息的速度大于消费者消费的速度的时候就要考虑用 work 工作模式，因为这样能提高处理速度提高负载！
	其实吧，work 模式就是比 simple 模式多了一些消费者，以前 simple 模式只有一个消费者在消费，如果你弄多个消费者那就变成了 work 模式并且这多个工作者之间就会满足上边 1,2 所讲的规则

### Rabbitmq工作模式订阅模式
1. X 代表交换机 rabbitMQ 内部组件，erlang 消息产生者是代码完成，代码的执行效率不高，消息产生者将消息放入交换机，交换机发布订阅把消息发送到所有消息队列中，对应消息队列的消费者拿到消息进行消费
2. 相关场景：邮件群发，群聊天，广播 (广告)
![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/b3fee8a7aa91d5d8c1e3c0ea0873d4fc&showdoc=.jpg)
Publish/Subscribe 订阅模式，消息被路由投递给多个队列，一个消息被多个消费者获取

### Rabbitmq模式Routing路由模式
	1. 消息生产者将消息发送给交换机按照路由判断，路由是字符串 (info) 当前产生的消息携带路由字符 (对象的方法), 交换机根据路由的 key, 只能匹配上路由 key 对应的消息队列，对应的消费者才能消费消息；
	2. 根据业务功能定义路由字符串
	3. 从系统的代码逻辑中获取对应的功能字符串，将消息任务扔到对应的队列中业务场景:error 通知；EXCEPTION; 错误通知的功能；传统意义的错误通知；客户通知；利用 key 路由，可以将程序中的错误封装成消息传入到消息队列中，开发者可以自定义消费者，实时接收错误；
![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/3f23a5b38135b12b3eae5f41741aa1ca&showdoc=.jpg)
	一个消息被多个消费者获取，并且消息的目标队列可以被生产者指定
	从生产端就可以指定队列消息的消费者是谁
	交换机的类型是 direct 类型 在订阅模式下是 faout 广播类型 这里是发生了变化的
	多个消费者传入相同的 key 那么可以实现多个消费者消费一个队列的消息的功能！

### Rabbitmq工作模式之topic模式
	1. 星号井号代表通配符
	2. 星号代表多个单词，井号代表一个单词
	3. 路由功能添加模糊匹配
	4. 消息产生者产生消息，把消息交给交换机
	5. 交换机根据 key 的规则模糊匹配到对应的队列，由队列的监听消费者接收消息消费
	一个消息被多个消费者获取。消息的目标 queue 可用 bindingkey 以通配符（#：一个或者多个词，*: 一个词）的方式指定
![](http://showdoc.siwei.com/server/index.php?s=/api/attachment/visitFile/sign/74a872d8f1d2b34c514171bbf1a26f28&showdoc=.jpg)
再说的直白一点其实就是根据传入的 key 进行模糊匹配 匹配到 key 之后就去找交换机上跟这个 key 绑定的队列去读取进行消费 当然匹配到可能多个 key 那么可能就会有多个队列被消费！
[文章出处](https://learnku.com/docs/go-szgbf/1.0/introduction-to-rabbitmq/8717 "文章出处")