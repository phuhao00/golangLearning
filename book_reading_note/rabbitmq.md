#### 消息中间件作用：

1.冗余（存储）：有些情况，处理数据的过程会失败。

2.扩展性：因为消息中间件解耦了应用的处理过程，所以提高消息入队列和处理的效率是很容易的，只要

另外增加处理的过程即可，不需要改变代码，也不需要调节参数。

3.削峰：在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果以能

处理这类峰值为标准而投入资源，无疑是巨大的浪费。使用消息中间件能够使关键组件支撑突发访问压力，

不会因为突发的超负荷请求而完全崩溃。

4.可恢复性：当系统一部分组件失效时，不会影响到整个系统。消息中间件降低了进程间的耦合度，所以

即使一个处理消息的进程挂掉，加入消息中间件中的消息仍然可以在系统恢复后进行处理。

5.顺序保证：在大多数使用场景下，数据处理的顺序很重要，大部分消息中间件支持一定的顺序性。

6.缓冲：在任何重要的系统中，都会存在需要不同处理时间的元素。消息中间件通过一个缓冲层来帮助任务高效地执行，写入消息中间件的处理尽可能快速。该缓冲层有助于控制和优化数据流经过系统的速度。

7.异步通信：在很多时候应用不想也不需要立即处理消息。消息中间件提供了异步处理机制，允许应用把一些消息

放入消息中间件中，但并不立即处理它，在之后需要的时候再慢慢处理。



### Rabbitmq常用的交换器类型

有fanout,direcy,topic,headers。



fanout

它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。

direct 

它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。

topic

它在direct基础上做了扩展，

RoutingKey为一个点“.”分隔的字符串。

BindingKey和RoutingKey一样也是点号“.”分隔的字符串。

BindingKey中可以存在两种特殊字符串“*"和“#”,用于做模糊匹配。

headers

它不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容的headers属性进行匹配。

交换性能会很差，而且也 不实用，基本上不会看到它的存在。



Connection 和Channel

无论是生成者还是消费者，都需要和RabbitMq Broker建立连接，这个连接就是一条TCP连接，也就是

Connection。一旦TCP连接建立起来，客户端紧接着可以创建一个AMQP信道（Channel）,每个信道

都会被指派一个唯一的ID。信道是建立在Connection之上的虚拟连接，RabbitMQ处理每条AMQP指令都是

通过信道完成的。（信道，Channel，一个应用程序中有很多个线程需要从RabbitMq中消费消息，或者生产消

息，那么必然要建立很多个Connection，也就是许多个TCP连接。然而对于操作系统而言，建立和销毁TCP连接是

非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。RabbitMq采用类似NIO的做法，选择TCP连接复

用，不仅可以减少性能开销，同时便于管理）





IsOpen 方法

在调用createXXX或者newXXX方法之后，我们可以简单地认为Connection或者Channel已经成功地处于开启状态，

而并不会在代码中使用IsOpen这个检测方法。



exchangeDeclare参数说明：

autoDelete :设置是否自动删除。autoDelete设置为true则表示自动删除。自动删除的前提是至少有一个队列或者交换器

与这个交换器绑定，之后所有与这个交换器绑定的队列或者交换器都与此解绑。注意不能错误的理解为：“当与此交换器

连接的客户端断开时，RabbitMq会自动删除本交换器”。

internal：设置是否是内置的。如果设置为true ，则表示是内置的交换器，客户端无法直接发送消息到这个交换器中，只能

通过交换器路由到交换器这种方式。



queueDeclare 参数说明：



exclusive：设置是否排他。为true则设置队列为排他的。如果一个队列被声明为排他队列，该队列仅对首次声明他的连接可见，

并在连接断开时自动删除。这里需要注意三点：排他队列是基于连接（Connection）可见的，同一个连接的不同信道（Channel）

是可以同时访问同一连接创建的排他队列：“首次”是指如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，

这个与普通队列不同；即时该队列是持久话的，一旦 连接关闭或者客户端退出，该排他队列都会自动删除，这种队列适用于一个客户端

同时发送和读取消息的应用场景。



autoDelete ：设置是否自动删除。为 true 则设置队列为自动删除。自动删除的前提是：

至少有一个消费者连接到这个队列，之后所有与这个队列连接的消费者都断开时，才会

自动删除。不能把这个参数错误地理解为：“当连接到此队列的所有客户端断开时，这

个队列自动删除”，因为生产者客户端创建这个队列，或者没有消费者客户端与这个队

列连接时，都不会自动删除这个队列。



注意要点：

生产者和消费者都能够使用 queueDeclare 来声明一个队列，但是如果消费者在同一个

信道上订阅了另一个队列，就无法再声明队列了。必须先取消订阅，然后将信道直为“传输”模式，之后才能声明队列。



RabbitMQ 的消息存储在队列中，交换器 并不真正耗费 器的 能，而队列会。要衡量 RabbitMQ 当前的 QPS 只需看队列的即可



按照 RabbitMQ 官方建议，生产者和消费者都应该尝试创建（这里指声明操作）队列。这是

一个很好的建议，但不适用于所有的情况。如果业务本身在架构设计之初己经充分地预估了队列

的使用情况，完全可以在业务程序上线之前在服务器上创建好（比如通过页面管理、 RabbitMQ

命令或者更好的是从配置中心下发），这样业务程序也可以免去声明的过程，直接使用即可。



Rabbi tMQ 的消费模式分两种 推（ Push ）模式和拉（ Pull ）模式 推模式采用 Basic Consume

进行消费，而拉模式则是调用 Basic Get 进行消费。

### 推模式

参数说明

consumerTag ：消费者标签，用来区分多个消费者：

noLocal 设置为 true 则表示不能将同一个 Connection中生产者发送的消息传送给

这个 Connection 中的消费者：



每个 Channel 都拥有自己独立的线程。最常用的做法是一 个Channel 对应一个消费者，

也就是意味着消费者彼此之间没有任何关联。当然也可以在一个 Channel 中维持多个消费者，

但是要注意 个问题，如果 Channel 中的 一个消费者一 直在运行，那么其他消费者的 callback

会被“耽搁。



### 拉模式

参数说明

注意要点：

Basic Consume 将信道（ Channel ）直为接收模式，直到取消队列的订阅为止。在接收

模式期间， RabbitMQ 会不断地推送消息给消费者，当然推送消息的个数还是会受到 Basic.Qos

的限制．如果只想从队列获得单条消息而不是持续订阅，建议还是使用 Basic.Get 进行消费．但

是不能将 Basic.Get 放在一个循环里来代替 Basic.Consume ，这样做会严重影响 RabbitMQ

的性能．如果要实现高吞吐量，消费者理应使用 Basic.Consume 方法。



##  消费端的确认与拒绝

当autoAck 参数置为 false ，对于 RabbitMQ 服务端而 ，队列中的消息分成了两个部分

部分是等待投递给消费者的消息： 部分是己经投递给消费者，但是还没有收到消费者确认

信号的消息。如果 RabbitMQ 直没有收到消费者的确认信号，并且消费此消息的消费者己经

断开连接，则 RabbitMQ 会安排该消息重新进入队列，等待投递给下 个消费者，当然也有可

能还是原来的那个消费者。



在消费者接收到消息后，如果想明确拒绝当前的消息而不是确认，那么应该怎么做呢？

RabbitMQ 2.0.0 版本开始引入了 Basic.Reject 这个命令，消费者客户端可以调用与其对

应的 channel.basicReject 方法来告诉 RabbitMQ 拒绝这个消息。



 basicReject(long deliveryTag, boolean requeue) 



其中 deliveryTag 可以看作消息的编号，它是一个 64 位的长整型值，最大值是

9223372036854775807 。如果 requeue 参数设置为 true ，则 RabbitMQ 会重新将这条消息存入

队列，以便可以发送给下一个订阅的消费者；如果 requeue 参数设置为 false ，则 RabbitMQ

立即会把消息从队列中移除，而不会把它发送给新的消费者。



### 消息何去何从

mandatory immediate channel basicPublish 方法中的两个参数，它们都有

当消息传递过程中不可达目的地时将消息返回给生产者的功能。



### mandatory 

mandatory 参数设为 true 时，交换器无法根据自身的类型和路由键找到一个符合条件

的队列，那么 RabbitM 会调用 Basic.Return 命令将消息返回给生产者。当 mandatory

数设置为 false 时，出现上述情形，则消息直接被丢弃

### immediate 

immediate 参数设为 true 时，如果交换器在将消息路由到队列时发现队列上并不存在

任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，

该消息会通过 Basic .Return 返回至生产者。



概括来说， mandatory 参数告诉服务器至少将该消息路由到一个队列中，否则将消息返

回给生产者, immediate 参数告诉服务器，如果该消息关联的队列上有消费者，则立刻投递：

如果所有匹配的队列上都没有消费者，则直接将消息返还给生产者，不用将消息存入队列而等

待消费者了。



RabbitMQ 3.0 版本开始去掉了对 immediate 参数的支持，对此 RabbitMQ 官方解释是：

immediate 参数会影响镜像队列的性能，增加了代码复杂性，建议采用 TTL DLX 的方法替代。



###  Alternate Exchange

备份交换器，英文名称为 Alternate Exchange ，简称AE，或者更直白地称之为“备胎交换器”。

生产者在发送消息的时候如果不设置 mandatory 参数，那么消息在未被路由的情况下将会丢失：

如果设置了 mandatory 参数，那么需要添加 ReturnListener 的编程逻辑，生产者的代码将

变得复杂。如果既不想复杂化生产者的编程逻辑，又不想消息丢失，那么可以使用备份交换器，

这样可以将未被路由的消息存储在 RabbitMQ 中，再在需要的时候去处理这些消息。

可以通过在声明交换器（调用 channel exchangeDeclare 方法）的时候添加

alternate-exchange 参数来实现，也可以通过策略（ Policy ，详细参考 6.3 节〉的方式实现。

如果两者同时使用，则前者的优先级更高，会覆盖掉 Policy 的设置。



## 过期时间（ TTL)



目前有两种方法可以设置消息的 TTL 。第一种方法是通过队列属性设置，队列中所有消息

都有相同的过期时间。第二种方法是对消息本身进行单独设置，每条消息的 TTL 可以不同。如

果两种方法一起使用，则消息的 TTL 以两者之间较小的那个数值为准。消息在队列中的生存时间

一旦超过设置 TTL 值时，就会变成“死信”（ Dead Message ），消费者将无法再收到该消息

（这点不是绝对的）





## 死信队列

DLX ，全称为 Dead-Letter-Exchange ，可以称之为死信交换器，也有人称之为死信邮箱。当

消息在一个队列中变成死信（ dead message ）之后，它能被重新被发送到另一个交换器中，这个

交换器就是 DLX ，绑定 DLX 的队列就称之为死信队列。

消息变成死信 般是由于以下几种情况：

1.消息被拒绝（ Basic.Reject/Basic.Nack ），井且设置 requeue 参数为 false;

2.消息过期；

3.队列达到最大长度。



DLX 也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实

际上就是设置某个队列的属性。当这个队列中存在死信时 RabbitMQ 就会自动地将这个消息

新发布到设置的 DLX 上去，进而被路由到另一个队列，即死信队列。可以监听这个队列中的消

息、以进行相应的处理，这个特性与将消息的 TTL 设置为 配合使用可以弥补 immediate 参数

的功能。





## 延迟队列



延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指当消息被发送以后，并不

想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费



延迟队列的使用场景有很多，比如：

令在订单系统中， 个用户下单之后通常有 分钟的时间进行支付，如果 分钟之内

没有支付成功，那么这个订单将进行异常处理，这时就可以使用延迟队列来处理这些

订单了。

用户希望通过手机远程遥控家里的智能设备在指定的时间进行工作。这时候就可以将

用户指令发送到延迟队列，当指令设定的时间到了再将指令推送到智能设备





AMQP 协议中，或者 RabbitMQ 本身没有直接支持延迟队列的功能，但是可以通过前面

所介绍的 DLX TTL 模拟出延迟队列的功能。



## 优先级队列

优先级队列，顾名思义，具有高优先级的队列具有高的优先权，优先级高的消息具备优先

被消费的特权。





## RPC 实现

RPC ，是 Remote Procedure Call 的简称，即远程过程调用 。它是一种通过网络从远程计算

机上请求服务，而不需要了解底层网络的技术。 RPC 的主要功用是让构建分布式计算更容易，

在提供强大的远程调用能力时不损失本地调用的语义简洁性。



## 持久化



RabbitMQ的持久化分为三个部分：交换器的持久化、队列的持久化和消息的持久化



交换器的持久化是通过在声明队列是将 durable 参数置为 true 实现的。

如果交换器不设置持久化，那么在 RabbitMQ 服务重启之后，相关的交换器元数据会丢失，

不过消息不会丢失，只是不能将消息发送到这个交换器中了 ,对于一个长期使用的交换器来说，

建议将其置为持久化的。



队列的持久化是通过在声明队列时将 durable 参数置为 true 实现的。

如果 队列不设置持久化，那么在 RabbitMQ 服务重启之后，相关队列的元数据会丢失，

此时数据也会丢失 。正所谓 “皮之不存，毛将焉附”，队列都没有 了，消息又能存在哪里呢？



队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的

消息不会丢失。要确保消息不会丢失，需要将其设置为持久化 通过将消息的投递模式 

(Bas icProperties 中的 deliveryMode 属性）设置为 2即可实现消息的持久化



设置了队列和消息的持久化，当 RabbitMQ 服务重启之后，消息依旧存在。单单只设置队

列持久化，重启之后消息会丢失；单单只设置消息的持久化，重启之后队列消失，继而消息也

丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。



注意要点：

可以将所有的消息都设置为持久化，但是这样会严重影响 RabbitMQ 的性能（随机）。写入

磁盘的速度比写入内存的速度慢得不只一点点。对于可靠性不是那么高的消息可以不采用持久

化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一

个权衡。



将交换器、队列、消息都设置了持久化之后就能百分之百保证数据不丢失了吗？答案是否

定的。

首先从消费者来说，如果在订阅消费队列时将 autoAck 参数设置为 true ，那么当消费者接

收到相关消息之后，还没来得及处理就看机了，这样也算数据丢失。这种情况很好解决，将

autoAck 参数设置为 false ，并进行手动确认



其次，在持久化的消息正确存入 RabbitMQ 之后，还需要有一段时间（虽然很短，但是不

可忽视〉才能存入磁盘之中。 RabbitMQ 并不会为每条消息都进行同步存盘（调用内核的 fsync1

方法）的处理，可能仅仅保存到操作系统缓存之中而不是物理磁盘之中。如果在这段时间内

RabbitMQ 服务节点发生了岩机、重启等异常情况，消息保存还没来得及落盘，那么这些消息将

会丢失。

这个问题怎么解决呢？这里可以引入 RabbitMQ 镜像队列机制，相当于配置了副本，

如果主节点（ master ）在此特殊时间内挂掉，可以自动切换到从节点（ lave ),

这样有效地保证了高可用性，除非整个集群都挂掉。虽然这样也不能完全保证 RabbitMQ 消息

不丢失，但是配置了镜像队列要比没有配置镜像队列的可靠性要高很多，在实际生产环境中的

关键业务队列一般都会设置镜像队列。

还可以在发送端引入事务机制或者发送方确认机制来保证消息己经正确地发送并存储至

RabbitMQ 中，前提还要保证在调用 channel .bas icPublish 方法的时候交换器能够将消息

正确路由到相应的队列之中。



## 生产者确认

如果在消息到达服务器之前己经丢失，持久化操作也解决不了这个问题，因为消息根本没有到达

服务器，何谈持久化？



RabbitMQ 针对这个问题，提供了两种解决方式：

通过事务机制实现：

通过发送方确认（publisher confirm ）机制实现。



## 消费端要点介绍



消费者客户端可以通过推模式或者拉模式的方

式来获取井消费消息，当消费者处理完业务逻辑需要手动确认消息己被接收，这样 RabbitMQ

才能把当前消息从队列中标记清除。当然如果消费者由于某些原因无法处理 前接收到的消息，

可以通过 channel basicNack 或者 channel basicReject 来拒绝掉



RabbitMQ 消费端来说，还有几点需要注意：

消息分发；

消息顺序性；

弃用 QueueingConsumer



### 消息分发



当RabbitMQ 队列拥有多个消费者时，队列收到的消息将以轮询（ round-robin ）的分发方式

发送给消费者。每条消息只会发送给订阅列表里的一个消费者。这种方式非常适合扩展，而且

它是专门为并发程序设计的。如果现在负载加重，那么只需要创建更多的消费者来消费处理消

息即可。



注意要点：

Basic.Qos 的使用对于拉模式的消费方式无效．



### 消息顺序性



消息的顺序性是指消费者消费到的消息和发送者发布的消息的顺序是一致的。



哪些情况下 RabbitMQ 的消息顺序性会被打破呢



如果生产者使用了事务机制，在发送消息之后遇到异常进行了事务回滚，那么需要重新补

偿发送这条消息，如果补偿发送是在另一个线程实现的 ，那么消息在生产者这个源头就出现了

错序。同样，如果启用 publisher confirm 时，在发生超时、中断，又或者是收到 RabbitMQ

Basic.Nack 命令时，那么同样需要补偿发送，结果与事务机制一样会错序。或者这种说法有

些牵强，我们可以固执地认为消息的顺序性保障是从存入队列之后开始的，而不是在发迭的时

候开始的。

考虑另 种情形，如果生产者发送的消息设置了不同的超时时间，井且也设置了死信队列，

整体上来说相当于 个延迟队列，那么消费者在消费这个延迟队列的时候，消息的顺序必然不

会和生产者发送消息的顺序一致。

再考虑 种情形，如果消息设置了优先级，那么消费者消费到的消息也必然不是顺 性的

如果 个队列按照前后顺序分有 msgl, msg2 msg3 msg4 个消息，同时有 ConsumerA 

和ConsumerB 这两个消费者同时订阅了这个队列。队列中的消息轮询分发到各个消费者之中，

ConsumerA 中的消息为 msgl msg3, ConsumerB 中的消息为 msg2 msg4 Consumer 收到

消息 msg 之后并不想处理而调用了 Basic Nack/.Reject 将消息拒绝，与此同时将

requeue 设置为 true ，这样这条消息就可以 新存入队列中 消息 msgl 之后被发送到了

ConsumerB 中，此时 ConsumerB 己经消费了 msg2 msg4 ，之后再消费 msgl ，这样消息顺序性

也就错乱了。或者消息 msgl 又重新发往 Consumer A中，此时 ConsumerA 消费了 msg3,

那么再消费 msgl ，消息顺序性也无法得到保障 同样可以用在 Basic.Rec ver 这个 AMQP

命令中



包括但不仅限于以上几种情形会使 RabbitMQ 消息错序 如果要保证消息的顺序性，需要

业务方使用 RabbitMQ 之后做进 步的处理，比如在消息体内添加全局有序标识（类似 Sequence

ID ）来实现



## 消息传输保障



消息可靠传输一般是业务系统接入消息中间件时首要考虑的问题， 一般消息中间件的消息

传输保障分为三个层级。



At most once ：最多一次。消息可能会丢失，但绝不会重复传输。

At least once ：最少一次。消息绝不会丢失，但可能会重复传输。

Exactly once ：恰好一次。每条消息肯定会被传输一次且仅传输一次。



RabbitMQ 支持其中的“最多一次”和“最少一次”。其中“最少 次”投递实现需要考虑

以下这个几个方面的内容：

(1）消息生产者需要开启事务机制或者 publisher confirm 机制，以确保消息可以可靠地传

输到 RabbitMQ 中。

(2 ）消息生产者需要配合使用 mandatory 参数或者备份交换器来确保消息能够从交换器

路由到队列中，进而能够保存下来而不会被丢弃。

(3 ）消息和队列都需要进行持久化处理，以确保 RabbitMQ 务器在遇到异常情况时不会

造成消息丢失

(4 ）消费者在消费消息的同时需要将 autoAck 设置为 false ，然后通过手动确认的方式去

确认己经正确消费的消息，以避免在消费端引起不必要的消息丢失。



“最多一次”的方式就无须考虑以上那些方面，生产者随意发送，消费者随意消费，不过这

样很难确保消息不会丢失。





















